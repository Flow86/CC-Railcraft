--
-- plug 4 different bundled cables in:
--
-- left, back, right are for the 3 parallel block controllers
--   pre-detector -> red
--   blue -> switch A/B, B/C
--   parallel block "lime" -> lime
--   parallel block "green" -> green
--   (simply connect bundled cable to each parallel block)
--
-- front:
--   next block "lime" -> yellow
--   green -> previous block "green"
--   red  -> previous block "red"
--   (simply connect bundled cable to previous block)
--

-- config

cable_input =  { "left", "back", "right", "front" }
cable_output = { "left", "back", "right", "front" }

-- in
cable_input_red2   = { colors.magenta,  colors.magenta,  colors.magenta, }
cable_input_green2 = { colors.lime, colors.lime, colors.lime }
cable_input_green3 = colors.yellow

-- out
cable_output_green3  = { colors.green, colors.green, colors.green }
cable_output_switch2 = { colors.blue,  colors.blue,  nil }

cable_output_green1 =  colors.green
cable_output_red1   =  colors.red

-- end config

state_signal = { false, false, false }

raise_state_red2   = { false, false, false }
raise_state_green2 = { false, false, false }
raise_state_green3 = false

cable_state_switch2 = { false, false, false }
cable_pulse_green3  = { false, false, false }
cable_state_red1   = true
cable_pulse_green1 = false

local function saveState()
	f = fs.open("/signal"..tostring(os.getComputerID())..".state", "w")
	--f.write(state_signal)
	f.close()
end

local function restoreState()
	f = fs.open("/signal"..tostring(os.getComputerID())..".state", "r")
	if f ~= nil then
		--state_signal = f.readAll()
		f.close()
	end
end

local function calculateUsed()
	local used = 0
	local usedp = { nil, nil, nil }
	for i=1,#state_signal do
		if not state_signal[i] then
			used = used + 1
			usedp[used] = i
		end
	end
	
	return used, usedp
end

local function printHeader()
	local w, h = term.getSize()
	
	term.setCursorPos(1,1)
	print("Multi Block Processor #", os.getComputerID())
	
	term.setCursorPos(1, h-1)
	print("=== Press Q to terminate. ===")

	term.setCursorPos(1, 7)
end

local function updateState()
	for i=1,#state_signal do
		-- send power to switch track
		if cable_output_switch2[i] ~= nil then
			setBundledState(cable_output[i], cable_output_switch2[i], cable_state_switch2[i])
		end
		
		-- puls green to parallel block
		if cable_pulse_green3[i] then
			cable_pulse_green3[i] = false
			pulseBundledState(cable_output[i], cable_output_green3[i], true)
		end
	end

	-- send red to previous block
	setBundledState(cable_output[4], cable_output_red1, cable_state_red1)

	-- pulse green to previous block
	if cable_pulse_green1 then
		cable_pulse_green1 = false
		pulseBundledState(cable_output[4], cable_output_green1, true)
	end
end

local function printState()
	term.setCursorPos(1, 2)
	used, usedp = calculateUsed()
	print("Free Tracks: ", used)

	term.clearLine(4)
	print("T #1: ", state_signal[1], "  #2: ", state_signal[2], "  #3: ", state_signal[3])
	term.clearLine(5)
	print("S #1: ", cable_state_switch2[1], "  #2: ", cable_state_switch2[2], "  #3: ", cable_state_switch2[3])
end

-- end functions

-- reset terminal
term.clear()

shell.run('debug.lua')
shell.run('bundle.lua')

setDebug("top", 1)
enableDebug()

-- reset cable
for i=1,#cable_output do
	rs.setBundledOutput(cable_output[i], 0)
end

-- initial print
restoreState()
updateState()
printState()

while true do
	printHeader()

	local event, param = os.pullEvent()
	
	if event == "char" then
		if string.lower(param) == "q" then
			term.clear()
			term.setCursorPos(1, 1)
			break
		end
		if string.lower(param) == "d" then
			toggleDebug()
		end
	end
	
	if event == "redstone" then
		for i=1,#state_signal do
			local input_state = rs.getBundledInput(cable_input[i])
			
			if colors.test(input_state, cable_input_red2[i]) then
				if not raise_state_red2[i] then
					debugPrint("Raising Red #", i, " ...")
					raise_state_red2[i] = true
				end
				
				-- block is occupied now
				
				-- react on active cable (block marked as red)
				state_signal[i] = false
				
				used, usedp = calculateUsed()
				if used == 0 then
					cable_state_red1 = true
				end
				
				-- instantly activate switch-track
				cable_state_switch2[i] = true
			else
				if raise_state_red2[i] then
					debugPrint("Falling Red #", i, " ...")
					raise_state_red2[i] = false
				end
			end
		
			if colors.test(input_state, cable_input_green2[i]) then
				if not raise_state_green2[i] then
					debugPrint("Raising Green #", i, " ...")
					raise_state_green2[i] = true
				end
			else
				if raise_state_green2[i] then
					debugPrint("Falling Green #", i, " ...")
					raise_state_green2[i] = false
					
					-- block is now free
					
					-- react on falling edge (block marked as green)
					state_signal[i] = true

					used, usedp = calculateUsed()
					if used ~= 0 then
						cable_state_red1 = false
						cable_pulse_green1 = true
					end
					
					-- deactivate switch-track
					cable_state_switch2[i] = false
				end
			end
		end
		
		local input_state = rs.getBundledInput(cable_input[4])
		if colors.test(input_state, cable_input_green3) then
			if not raise_state_green3 then
				debugPrint("Raising Out Green ...")
				raise_state_green3 = true
			end
		else
			if raise_state_green3 then
				debugPrint("Falling Out Green ...")
				raise_state_green3 = false
				
				-- path is now free
				-- now activate one of the (used) 3 blocks

				local used, usedp = calculateUsed()
				if used ~= 0 then
					-- react on falling edge (path marked as green)
					cable_pulse_green3[usedp[math.random(1, used)]] = true
				end
			end
		end
	end
	
	updateState()
	printState()
end

-- reset cable on exit
for i=1,#cable_output do
	rs.setBundledOutput(cable_output[i], 0)
end

-- eof