-- being config

cable = "back"

-- in
signal_red2 = { colors.red, colors.magenta, colors.orange }
signal_green2 = { colors.green, colors.cyan, colors.yellow }

-- out
signal_green1 = colors.lime
signal_red1 = colors.lightGray
signal_switch2 = { colors.blue, colors.lightBlue }

-- end config

raise_red2 = { false, false, false }
state_red2 = { false, false, false }
raise_green2 = { false, false, false }
state_green2 = { false, false, false }
state_switch2 = { false, false, false }

initialize = true

-- reset terminal
term.clear()

shell.run('debug.lua')
shell.run('bundle.lua')

local function printHeader()
	local w, h = term.getSize()
	
	term.setCursorPos(1,1)
	print("Multi Block Processor (Front)")
	
	term.setCursorPos(1,3)
	print("Config: Cable at ", cable)

	term.setCursorPos(1, h-1)
	print("=== Press Q to terminate. ===")

	term.setCursorPos(1, 6)
end

local function updateState()
	-- if we have one green signal, one train can pass
	local free = 0
	
	for i=1,#signal_green2 do
		if state_green2[i] then
			debugPrint("Signal", i, " switch Green: ", tostring(state_signal_old))
			state_signal = true
			state_switch2[i] = false
			free = free + 1
		end
	end

	debugPrint("Free: ", free)
	
	for i=1,#signal_red2 do
		if state_red2[i] then
			state_switch2[i] = true
		end
	end
	
	-- set switch track state
	for i=1,#signal_switch2 do
		setBundledState(cable, signal_switch2[i], state_switch2[i])
	end
	
	-- force green
	--if free > 0 and state_signal_old == state_signal then
	--	state_signal_old = not state_signal
	--end

	-- set signal state
	if initialize or state_signal_old ~= state_signal then
		initialize = false
		
		if state_signal then
			debugPrint("Switching Entry to Green")
		else
			debugPrint("Switching Entry to Red")
		end
		
		-- send light signal to previous block
		setBundledState(cable, signal_red1, not state_signal)
		
		-- send block state to previous block
		if state_signal then
			setBundledState(cable, signal_green1, true)
			sleep(0.1)
			setBundledState(cable, signal_green1, false)
		end
	end
end

local function printState()
	term.setCursorPos(1, 4)
	
	if state_signal then
		print("State:  Green")
	else
		print("State:  Red  ")
	end
	
	term.clearLine(5)
	print("Red:    ", tostring(state_red2[1]), " ", tostring(state_red2[2]), " ", tostring(state_red2[3]))
	term.clearLine(6)
	print("Green:  ", tostring(state_green2[1]), " ", tostring(state_green2[2]), " ", tostring(state_green2[3]))
	term.clearLine(7)
	print("Switch: ", tostring(state_switch2[1]), " ", tostring(state_switch2[2]))
end
-- end functions

-- reset cable
rs.setBundledOutput(cable, 0)

setDebug("top", 1)
enableDebug()

-- initial print
updateState()
printState()

while true do
	printHeader()

	local event, param = os.pullEvent()
	
	if event == "char" then
		if string.lower(param) == "q" then
			term.clear()
			term.setCursorPos(1, 1)
			print("Program terminated.")
			break
		end
		if string.lower(param) == "d" then
			toggleDebug()
		end
	end
	
	state_signal_old = state_signal
	
	local state = rs.getBundledInput(cable)
	
	if event == "redstone" then
		local state = rs.getBundledInput(cable)
		
		-- directly set red
		for i=1,#signal_red2 do
			if colors.test(state, signal_red2[i]) then
				if not raise_red2[i] then
					debugPrint("Raising Red #", i, " ...")
					raise_red2[i] = true
					state_red2[i] = true
					state_signal = false
				end
				state_green2[i] = false
			else
				if raise_red2[i] then
					debugPrint("Falling Red #", i, " ...")
					state_red2[i] = false
				end
				raise_red2[i] = false
			end
		end
		
		for i=1,#signal_green2 do
			-- react on falling edge
			if colors.test(state, signal_green2[i]) then
				if not raise_green2[i] then
					debugPrint("Raising Green #", i, " ...")
					raise_green2[i] = true
				end
			else
				if raise_green2[i] then
					debugPrint("Falling Green #", i, " ...")
					state_green2[i] = true
				end
				raise_green2[i] = false
			end
		end
		
		-- os.startTimer event == timer
	end
	
	updateState()
	printState()
	
end

-- reset cable on exit
rs.setBundledOutput(cable, 0)

-- eof